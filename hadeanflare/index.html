<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hadean Flare v2 (Wandering Mod)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_resolution;
        
        // MODIFICATION: Replaced u_time with a 2D vector for scrolling
        uniform vec2 u_scroll_offset; 

        // Values from JavaScript
        uniform float u_noise_scale;
        uniform float u_warp_amount;
        uniform float u_warp_speed;
        uniform vec3 u_color1;
        uniform vec3 u_color2;
        uniform vec3 u_color3;
        uniform float u_saturation;

        // Helper functions (unchanged)
        vec3 rgb2hsv(vec3 c) { /* ... */ vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x); }
        vec3 hsv2rgb(vec3 c) { /* ... */ vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y); }
        vec2 hash( vec2 p ) { /* ... */ p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));return-1.+2.*fract(sin(p)*43758.5453123); }
        float noise( in vec2 p ) { /* ... */ const float K1=.366025404,K2=.211324865;vec2 i=floor(p+(p.x+p.y)*K1);vec2 a=p-i+(i.x+i.y)*K2;vec2 o=(a.x>a.y)?vec2(1.,0.):vec2(0.,1.);vec2 b=a-o+K2;vec2 c=a-1.+2.*K2;vec3 h=max(.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.);vec3 n=h*h*h*h*vec3(dot(a,hash(i+0.)),dot(b,hash(i+o)),dot(c,hash(i+1.)));return dot(n,vec3(70.)); }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            
            // MODIFICATION: Using the 2D scroll offset for the warp effect
            vec2 warp_offset = vec2(noise(uv * u_noise_scale * 0.5 + u_scroll_offset * u_warp_speed), noise(uv * u_noise_scale * 0.5 + u_scroll_offset * u_warp_speed + 10.0));
            vec2 warped_uv = uv + (warp_offset * u_warp_amount);
            
            // MODIFICATION: Using the 2D scroll offset for the main pattern
            float noiseValue = (noise(warped_uv * u_noise_scale + u_scroll_offset) + 1.0) * 0.5;

            vec3 color = mix(u_color1, u_color2, smoothstep(0.0, 0.5, noiseValue));
            color = mix(color, u_color3, smoothstep(0.5, 1.0, noiseValue));
            
            vec3 hsv = rgb2hsv(color);
            hsv.y *= u_saturation;
            color = hsv2rgb(hsv);
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // Simplex noise implementation (unchanged)
        (function(){"use strict";var F2=0.5*(Math.sqrt(3)-1),G2=(3-Math.sqrt(3))/6,F3=1/3,G3=1/6;function SimplexNoise(random){if(!random)random=Math.random;this.p=new Uint8Array(256);this.perm=new Uint8Array(512);this.permMod12=new Uint8Array(512);for(var i=0;i<256;i++)this.p[i]=i;for(var i=0;i<255;i++){var r=i+~~(random()*(256-i));var aux=this.p[i];this.p[i]=this.p[r];this.p[r]=aux}for(var i=0;i<512;i++){this.perm[i]=this.p[i&255];this.permMod12[i]=this.perm[i]%12}this.grad3=new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1])}SimplexNoise.prototype={noise:function(x,y){var n0,n1,n2;var s=(x+y)*F2;var i=Math.floor(x+s),j=Math.floor(y+s);var t=(i+j)*G2;var X0=i-t,Y0=j-t;var x0=x-X0,y0=y-Y0;var i1,j1;if(x0>y0){i1=1;j1=0}else{i1=0;j1=1}var x1=x0-i1+G2,y1=y0-j1+G2,x2=x0-1+2*G2,y2=y0-1+2*G2;var ii=i&255,jj=j&255;var gi0=this.permMod12[ii+this.perm[jj]];var gi1=this.permMod12[ii+i1+this.perm[jj+j1]];var gi2=this.permMod12[ii+1+this.perm[jj+1]];var t0=0.5-x0*x0-y0*y0;if(t0<0)n0=0;else{t0*=t0;n0=t0*t0*this.dot(this.grad3,gi0,x0,y0)}var t1=0.5-x1*x1-y1*y1;if(t1<0)n1=0;else{t1*=t1;n1=t1*t1*this.dot(this.grad3,gi1,x1,y1)}var t2=0.5-x2*x2-y2*y2;if(t2<0)n2=0;else{t2*=t2;n2=t2*t2*this.dot(this.grad3,gi2,x2,y2)}return 70*(n0+n1+n2)},dot:function(g,gi,x,y){return g[gi]*x+g[gi+1]*y}};if(typeof define!=="undefined"&&define.amd)define(function(){return SimplexNoise});else if(typeof module!=="undefined"&&module.exports)module.exports=SimplexNoise;else if(typeof window!=="undefined")window.SimplexNoise=SimplexNoise;else self.SimplexNoise=SimplexNoise})();

        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) { alert('WebGL not supported!'); }

        // --- CUSTOMIZE HERE ---

        const noiseScale = 2.5;
        const timeSpeed = 0.1;
        const scrollWanderSpeed = 0.02;     // How fast the pattern wanders.
        const scrollWanderMagnitude = 2.0; // How far the pattern wanders from its origin.


        
        const warpAmount = 0.36;
        const warpSpeed = 0.02;

        // ** NEW INDEPENDENT COLOR SPEED CONTROLS **
        const color1Speed = 0.05; 
        const color2Speed = 0.07;
        const color3Speed = 0.09;

        // How much the speed can vary. 1.0 means it can vary by 100% (from near-zero to double speed)
        const speedVariability = 0.3; 
        const speedChangeFrequency = 0.04; // How quickly the speed itself changes

        const saturationChangeSpeed = 0.06;
        const minSaturation = 0.1;         
        const maxSaturation = 1.0;  
        // ----------------------

        function createShader(gl, type, source) { /* ... */ const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error('Shader compile error:', gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; }
        function createProgram(gl, vertexShader, fragmentShader) { /* ... */ const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error('Program link error:', gl.getProgramInfoLog(program)); gl.deleteProgram(program); return null; } return program; }

        const vsSource = document.getElementById('vertex-shader').text;
        const fsSource = document.getElementById('fragment-shader').text;
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
        // MODIFICATION: Get location for the new u_scroll_offset uniform
        const scrollOffsetUniformLocation = gl.getUniformLocation(program, "u_scroll_offset");
        const noiseScaleUniformLocation = gl.getUniformLocation(program, "u_noise_scale");
        const warpAmountUniformLocation = gl.getUniformLocation(program, "u_warp_amount");
        const warpSpeedUniformLocation = gl.getUniformLocation(program, "u_warp_speed");
        const color1UniformLocation = gl.getUniformLocation(program, "u_color1");
        const color2UniformLocation = gl.getUniformLocation(program, "u_color2");
        const color3UniformLocation = gl.getUniformLocation(program, "u_color3");
        const saturationUniformLocation = gl.getUniformLocation(program, "u_saturation");

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const simplex = new SimplexNoise();

        let lastTime = 0;
        let color1Progress = 0;
        let color2Progress = 0;
        let color3Progress = 0;
        let saturationProgress = 0;

        function render(time) {
            const deltaTime = (time - lastTime) * 0.001;
            lastTime = time;

            if (isNaN(deltaTime) || deltaTime > 0.5) {
                requestAnimationFrame(render);
                return;
            }
            
            time *= 0.001; // convert to seconds

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            // --- WANDERING SCROLL LOGIC ---
            const scrollTime = time * scrollWanderSpeed;
            // Generate two independent noise values for the X and Y scroll offsets
            const scrollOffsetX = simplex.noise(scrollTime, 100) * scrollWanderMagnitude;
            const scrollOffsetY = simplex.noise(scrollTime, 200) * scrollWanderMagnitude;

            // --- UNPREDICTABLE SPEED AND COLOR LOGIC (unchanged) ---
            const modTime = time * speedChangeFrequency;
            const speedMod1 = 1 + speedVariability * simplex.noise(modTime, 10.0);
            const speedMod2 = 1 + speedVariability * simplex.noise(modTime, 20.0);
            const speedMod3 = 1 + speedVariability * simplex.noise(modTime, 30.0);
            const speedModSat = 1 + speedVariability * simplex.noise(modTime, 40.0);

            color1Progress += color1Speed * speedMod1 * deltaTime;
            color2Progress += color2Speed * speedMod2 * deltaTime;
            color3Progress += color3Speed * speedMod3 * deltaTime;
            saturationProgress += saturationChangeSpeed * speedModSat * deltaTime;

            const gradientColor1 = [ (simplex.noise(color1Progress, 5) + 1) * 0.5, (simplex.noise(color1Progress, 15) + 1) * 0.5, (simplex.noise(color1Progress, 25) + 1) * 0.5 ];
            const gradientColor2 = [ (simplex.noise(color2Progress, 35) + 1) * 0.5, (simplex.noise(color2Progress, 45) + 1) * 0.5, (simplex.noise(color2Progress, 55) + 1) * 0.5 ];
            const gradientColor3 = [ (simplex.noise(color3Progress, 65) + 1) * 0.5, (simplex.noise(color3Progress, 75) + 1) * 0.5, (simplex.noise(color3Progress, 85) + 1) * 0.5 ];
            
            const sat_cycle = (simplex.noise(saturationProgress, 0) + 1.0) * 0.5;
            const currentSaturation = minSaturation + sat_cycle * (maxSaturation - minSaturation);

            // Pass all Uniforms to the Shader
            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            // MODIFICATION: Pass the new 2D scroll vector instead of the old time uniform
            gl.uniform2f(scrollOffsetUniformLocation, scrollOffsetX, scrollOffsetY);
            gl.uniform1f(noiseScaleUniformLocation, noiseScale);
            gl.uniform1f(warpAmountUniformLocation, warpAmount);
            gl.uniform1f(warpSpeedUniformLocation, warpSpeed);
            gl.uniform3fv(color1UniformLocation, gradientColor1);
            gl.uniform3fv(color2UniformLocation, gradientColor2);
            gl.uniform3fv(color3UniformLocation, gradientColor3);
            gl.uniform1f(saturationUniformLocation, currentSaturation);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>