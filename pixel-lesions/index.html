<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Lesions</title>
    <style>
        :root {
            --background-color: #1a1d1a;
            --panel-color: #252925;
            --text-color: #d0d5d0;
            --border-color: #3a3f3a;
            --accent-color: #8a9a5b; /* A sickly, desaturated chartreuse */
            --accent-hover: #a2b56b;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Menlo', 'Courier New', monospace;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 2rem;
        }

        h1 {
            font-weight: 400;
            letter-spacing: 0.1em;
            color: var(--text-color);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        p {
            color: #888;
            max-width: 600px;
            text-align: center;
            margin-top: 0;
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }

        #controls {
            margin-bottom: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            background-color: var(--panel-color);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);

        }

        label, .checkbox-container {
            color: #aaa;
        }

        button, select, input[type="file"]::file-selector-button {
            background-color: #333833;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        button:hover, select:hover, input[type="file"]::file-selector-button:hover {
            background-color: var(--border-color);
            border-color: #555;
        }
        
        #saveButton {
            background-color: var(--accent-color);
            border-color: #72814a;
            color: #111;
            font-weight: bold;
        }
        
        #saveButton:hover {
            background-color: var(--accent-hover);
            border-color: #8a9a5b;
        }

        select {
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 120px;
            background: transparent;
        }
input[type="range"]::-webkit-slider-runnable-track {
    height: 6px; /* Increased from 4px */
    background: var(--border-color); /* Using a lighter color */
    border-radius: 3px;
}

/* --- Add this new rule for Firefox compatibility --- */
input[type="range"]::-moz-range-track {
    height: 6px;
    background: var(--border-color);
    border-radius: 3px;
}
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--text-color);
            border-radius: 50%;
            margin-top: -6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-thumb {
            background: var(--accent-hover);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        canvas {
            border: 1px solid var(--border-color);
            background-color: #000;
            cursor: pointer;
            max-width: 90vw;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        canvas.dragging-over {
            border-color: var(--accent-color);
            box-shadow: 0 0 25px -5px var(--accent-color);
        }

    </style>
</head>
<body>

    <h1>Pixel Lesions</h1>
    <p>An instrument for organic pixel corruption. Drag & drop an image, or use the file chooser. Click to seed a lesion, click again to stop.</p>

    <div id="controls">
        <input type="file" id="imageLoader" accept="image/*">
        
        <label for="sortCriteria">Strain:</label>
        <select id="sortCriteria">
            <option value="brightness">Brightness</option>
            <option value="hue">Hue</option>
            <option value="saturation">Saturation</option>
            <option value="red">Red</option>
            <option value="green">Green</option>
            <option value="blue">Blue</option>
        </select>
        <div class="checkbox-container">
            <input type="checkbox" id="reverseSort">
            <label for="reverseSort">Reverse</label>
        </div>
        
        <label for="threshold">Tolerance:</label>
        <input type="range" id="threshold" min="1" max="500" value="50">
        
        <button id="stopButton">Stop & Freeze</button>
        <button id="resetButton">Reset</button>
        <button id="saveButton">Save Image</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // All JavaScript remains the same as the previous version.
        // The script from the last turn is included here for completeness.
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const imageLoader = document.getElementById('imageLoader');
        const sortCriteriaSelect = document.getElementById('sortCriteria');
        const reverseSortCheckbox = document.getElementById('reverseSort');
        const resetButton = document.getElementById('resetButton');
        const stopButton = document.getElementById('stopButton');
        const saveButton = document.getElementById('saveButton');
        const thresholdSlider = document.getElementById('threshold');

        let trueOriginalImageData = null;
        let workingImageData = null;
        let isProcessing = false;
        let animationFrameId = null;

        imageLoader.addEventListener('change', handleImageUpload);
        canvas.addEventListener('click', handleCanvasClick);
        stopButton.addEventListener('click', stopProcessing);
        resetButton.addEventListener('click', resetCanvas);
        saveButton.addEventListener('click', saveImage);
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            canvas.classList.add('dragging-over');
        });
        canvas.addEventListener('dragleave', () => {
            canvas.classList.remove('dragging-over');
        });
        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            canvas.classList.remove('dragging-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    loadImageFile(file);
                }
            }
        });

        function loadImageFile(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    stopProcessing();
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    trueOriginalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    workingImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function handleImageUpload(e) {
            if (e.target.files && e.target.files[0]) {
                loadImageFile(e.target.files[0]);
            }
        }

        function handleCanvasClick(e) {
            if (!workingImageData) return;
            if (isProcessing) {
                stopProcessing();
            } else {
                startFungalSort(e);
            }
        }

        function stopProcessing() {
            if (!isProcessing) return;
            cancelAnimationFrame(animationFrameId);
            isProcessing = false;
            workingImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        function resetCanvas() {
            stopProcessing();
            if (trueOriginalImageData) {
                workingImageData = trueOriginalImageData;
                ctx.putImageData(workingImageData, 0, 0);
            }
        }

        function saveImage() {
            const link = document.createElement('a');
            link.download = 'lesion-art.png';
            link.href = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
            link.click();
        }

        function startFungalSort(e) {
            isProcessing = true;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            
            const frontier = [[x, y]]; 
            const lesionCoords = []; 
            const infectedSet = new Set([`${x},${y}`]);
            const seedColor = getPixelColor(x, y, workingImageData);
            const COLOR_THRESHOLD = parseInt(thresholdSlider.value, 10);
            const BATCH_SIZE = 50; 

            function animate() {
                if (frontier.length === 0) {
                    stopProcessing();
                    return;
                }

                const batchLimit = Math.min(frontier.length, BATCH_SIZE);
                for (let i = 0; i < batchLimit; i++) {
                    const randomIndex = Math.floor(Math.random() * frontier.length);
                    const [currentX, currentY] = frontier.splice(randomIndex, 1)[0];
                    lesionCoords.push({ x: currentX, y: currentY });
                    const neighbors = [
                        [currentX, currentY - 1], [currentX, currentY + 1],
                        [currentX - 1, currentY], [currentX + 1, currentY]
                    ];
                    for (const [nx, ny] of neighbors) {
                        const key = `${nx},${ny}`;
                        if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height && !infectedSet.has(key)) {
                            const neighborColor = getPixelColor(nx, ny, workingImageData);
                            if (colorDistance(seedColor, neighborColor) < COLOR_THRESHOLD) {
                                infectedSet.add(key);
                                frontier.push([nx, ny]);
                            }
                        }
                    }
                }

                const lesionPixelsData = lesionCoords.map(coord => {
                    const color = getPixelColor(coord.x, coord.y, workingImageData);
                    return { ...color, coord };
                });
                const sortFunction = getSortFunction(sortCriteriaSelect.value);
                const isReversed = reverseSortCheckbox.checked;
                lesionPixelsData.sort(sortFunction);
                if (isReversed) {
                    lesionPixelsData.reverse();
                }
                
                const modifiedImageData = new ImageData(
                    new Uint8ClampedArray(workingImageData.data),
                    workingImageData.width
                );
                for (let i = 0; i < lesionCoords.length; i++) {
                    const originalCoord = lesionCoords[i];
                    const sortedPixel = lesionPixelsData[i];
                    const index = (originalCoord.y * canvas.width + originalCoord.x) * 4;
                    modifiedImageData.data[index] = sortedPixel.r;
                    modifiedImageData.data[index + 1] = sortedPixel.g;
                    modifiedImageData.data[index + 2] = sortedPixel.b;
                }
                ctx.putImageData(modifiedImageData, 0, 0);
                
                animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function getPixelColor(x, y, imageData) {
            const i = (y * imageData.width + x) * 4;
            return { r: imageData.data[i], g: imageData.data[i + 1], b: imageData.data[i + 2] };
        }
        function colorDistance(c1, c2) {
            return Math.sqrt(Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2));
        }
        function getSortFunction(criteria) {
            const colorSorters = {
                'red': (a, b) => a.r - b.r, 'green': (a, b) => a.g - b.g, 'blue': (a, b) => a.b - b.b,
                'brightness': (a, b) => getBrightness(a.r, a.g, a.b) - getBrightness(b.r, b.g, b.b),
                'hue': (a, b) => getHue(a.r, a.g, a.b) - getHue(b.r, b.g, b.b),
                'saturation': (a, b) => getSaturation(a.r, a.g, a.b) - getSaturation(b.r, b.g, b.b)
            };
            return colorSorters[criteria];
        }
        function getBrightness(r, g, b) { return 0.299 * r + 0.587 * g + 0.114 * b; }
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; } 
            else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h, s, l];
        }
        function getHue(r, g, b) { return rgbToHsl(r, g, b)[0]; }
        function getSaturation(r, g, b) { return rgbToHsl(r, g, b)[1]; }

    </script>
</body>
</html>